/*eslint-disable*/

// React imports
import React from 'react';
import { connect } from 'react-redux';
import { isEqual } from 'lodash';

import BubbleChart from '../../common/bubble-chart/bubble-chart';
import D3Legend from '../../common/clickable-legends-view/d3-legend';

import {fetchCveBubbleChartData, receiveNotifyAlertsResponse, setSearchQuery} from '../../../actions/app-actions';
import { EMPTY_STATE_TEXT } from '../../../constants/naming';
import { getOrderedData, luceneQueryChecker, updateSearchQueryArr } from '../../../utils/array-utils';
import {
  legendEdgeCaseCheck, maintainVisualizationData,
  modifyVisualizationData
} from '../../../utils/visualization-utils';
import {
  CVE_BUBBLE_CHART_UPPER_BOUND_LIMIT,
  BUBBLE_CHART_UPPER_BOUND_LIMIT_MESSAGE
} from "../../../constants/visualization-config";
import {TIME_BOUNDARY_OPTIONS} from "../../../constants/dashboard-refresh-config";

function getFormatedLegendsData(data) {
  const result = [];
  const uniqueSeverity = getUniqueSeverity(data);
  uniqueSeverity.forEach((uniqueRecord)=> {
    result.push({key_name: uniqueRecord.severity, key_value: 0, isChecked: true});
  });

  return result;
}

function getUniqueSeverity(data) {
  const result = [];
  data.forEach((record)=> {
    if (result.indexOf(record.cve_severity) === -1) {
      result.push(record.cve_severity);
    }
  });

  const resultArrWithSeverityCount = [];
  getOrderedData('severity', result).forEach((uniqueKey)=> {
    let counter = 0;
    for (let i=0; i<data.length; i++){
      if (uniqueKey == data[i].cve_severity){
        counter += data[i].count;
      }
    }
    resultArrWithSeverityCount.push({severity: uniqueKey, severityCount: counter})
  });

  return resultArrWithSeverityCount;
}

function getLuceneQueryOnBubbleClick(params) {
  let luceneQuery = '';
  luceneQuery += `(cve_id:"${params.cve_id}" AND cve_container_image:"${params.cve_container_image}")`

  return luceneQuery
}

class CvBubbleChartView extends React.Component {
  constructor() {
    super();
    this.state={};
    this.handleSingleClick = this.handleSingleClick.bind(this);
    this.handleDoubleClick = this.handleDoubleClick.bind(this);
  }

  componentDidMount() {
    // Initial api call to get data
    this.getCveBubbleChartData();

    // If props already updated load the data from props.
    if (this.props.cveBubbleChartData) {
      this.updateCveBubbleChart(modifyVisualizationData(this.props.cveBubbleChartData));
      this.initializeLegends(getFormatedLegendsData(this.props.cveBubbleChartData));
    }

    // Calls on the basis of active time interval
    if(this.props.refreshInterval){
      let interval = setInterval(()=>{
        this.getCveBubbleChartData();
      }, this.props.refreshInterval.value*1000);
      this.setState({intervalObj : interval});
    }
  }

  componentWillReceiveProps(newProps){
    if(newProps.refreshInterval && (this.props.refreshInterval != newProps.refreshInterval)){
      let interval = setInterval(()=>{
        this.getCveBubbleChartData();
      }, newProps.refreshInterval.value*1000);
      if(this.state.intervalObj){
        clearInterval(this.state.intervalObj);
      }
      this.setState({intervalObj : interval});
    }
    if (!isEqual(newProps.cveBubbleChartData, maintainVisualizationData(this.props.cveBubbleChartData))) {
      this.checkDataLength(newProps.cveBubbleChartData);
    } else if (newProps.searchQuery != this.props.searchQuery) {
      this.setState({ display: undefined, number: undefined, time_unit: undefined}, function stateUpdateComplete() {
        const activeDuration = newProps.days.value;
        this.getCveBubbleChartData(activeDuration.number, activeDuration.time_unit, newProps.searchQuery);
      }.bind(this));
    } else if (newProps.days != this.props.days) {
      this.setState({ display: undefined, number: undefined, time_unit: undefined}, function stateUpdateComplete() {
        const activeDuration = newProps.days.value;
        this.getCveBubbleChartData(activeDuration.number, activeDuration.time_unit, newProps.searchQuery);
      }.bind(this));
    }
  }

  componentWillUnmount(){
    // Clearing the intervals
    if(this.state.intervalObj){
      clearInterval(this.state.intervalObj);
    }
    // Resetting component states
    this.setState({
      tree_map_data: undefined,
      number: undefined,
      time_unit: undefined,
      display: undefined
    });
  }

  // Method to check data length before visualization update.
  checkDataLength(data) {
    if (data.length <= CVE_BUBBLE_CHART_UPPER_BOUND_LIMIT) {
      this.updateCveBubbleChart(modifyVisualizationData(data));
      this.initializeLegends(getFormatedLegendsData(data));
    } else {
      this.props.dispatch(receiveNotifyAlertsResponse(BUBBLE_CHART_UPPER_BOUND_LIMIT_MESSAGE));
      this.setPreviousDuration();
    }
  }

  // Method to set previous available option from time boundary options.
  setPreviousDuration() {
    let activeDuration = this.state.display ? this.state.display : this.props.days.display;
    const index = TIME_BOUNDARY_OPTIONS.findIndex(option => option.display == activeDuration);
    const previousOptionIndex = index - 1;
    const previousOption = TIME_BOUNDARY_OPTIONS[previousOptionIndex];
    this.setState({
      display: previousOption.display,
      number: previousOption.value.number,
      time_unit: previousOption.value.time_unit
    }, function stateUpdateComplete() {
      this.getCveBubbleChartData(this.state.number, this.state.time_unit, this.props.searchQuery);
    }.bind(this));
  }

  getCveBubbleChartData(number, time_unit, lucene_query) {
    if (this.props.days || number) {
      let params = {
        number: number || this.state.number || this.props.days.value.number,
        time_unit: time_unit || this.state.time_unit || this.props.days.value.time_unit,
        lucene_query: lucene_query || this.props.searchQuery,
        _type: 'cve'
      };
      this.props.dispatch(fetchCveBubbleChartData(params));
    }
  }

  updateCveBubbleChart(data){
    this.setState({cve_bubble_chart_data: data});
    this.setState({dataToBePopulate: data});
  }

  initializeLegends(legendsData) {
    this.setState({bubbleChartLegends: legendsData});
  }

  handleBubbleMouseInEvent(bubbleData) {
    this.setState({
      isTooltipVisible: true,
      bubbleDetails: bubbleData
    });
  }

  handleBubbleMouseOutEvent() {
    this.setState({
      isTooltipVisible: false,
      bubbleDetails: undefined
    });
  };

  handleBubbleClickEvent(data) {
    let params = {
      cve_id: data.cve_id,
      cve_container_image: data.cve_container_image
    };
    const luceneQuery = getLuceneQueryOnBubbleClick(params);
    const isLuceneQueryExist = luceneQueryChecker(this.props.searchQuery, `(${luceneQuery})`);

    let searchQuery = [];
    if (this.props.searchQuery.length > 0) {
      if (!isLuceneQueryExist) {
        searchQuery = updateSearchQueryArr(this.props.searchQuery, `(${luceneQuery})`);
      } else {
        searchQuery = this.props.searchQuery;
      }
    } else {
      searchQuery.push(`${luceneQuery}`);
    }

    this.props.dispatch(setSearchQuery({searchQuery:searchQuery}));
  }

  handleSingleClick(value) {
    this.updateBubbleChartOnSingleClick(value);
  }

  handleDoubleClick(legend) {
    this.updateBubbleChartOnDoubleClick(legend);
  }

  updateBubbleChartOnSingleClick(selectedLegend) {
    let activeBubbleChartData = JSON.parse(JSON.stringify(this.state.cve_bubble_chart_data));
    activeBubbleChartData.forEach((record)=> {
      if (record.cve_severity === selectedLegend[Object.keys(selectedLegend)[0]]) {
        if (record.isVisible) {
          record.isVisible = false;
        } else {
          record.isVisible = true;
        }
      }
    });
    const filteredData = this.getFilteredData(activeBubbleChartData);
    this.setState({dataToBePopulate: filteredData});
    this.setState({cve_bubble_chart_data: activeBubbleChartData});

    // Legend Update
    let activeLegends = JSON.parse(JSON.stringify(this.state.bubbleChartLegends));
    activeLegends.forEach((legend)=> {
      if (selectedLegend[Object.keys(selectedLegend)[0]] === legend.key_name){
        if (legend.isChecked) {
          legend.isChecked = false;
        } else {
          legend.isChecked = true;
        }
      }
    });
    this.setState({bubbleChartLegends: activeLegends});

    const isEdgeCase = legendEdgeCaseCheck(JSON.parse(JSON.stringify(this.state.cve_bubble_chart_data)));
    if (isEdgeCase) {
      this.updateCveBubbleChart(modifyVisualizationData(this.state.cve_bubble_chart_data));
      this.initializeLegends(getFormatedLegendsData(this.state.cve_bubble_chart_data));
    }
  }

  updateBubbleChartOnDoubleClick(selectedLegend) {
    let bubbleChartData = JSON.parse(JSON.stringify(this.state.cve_bubble_chart_data));

    // Visualization update
    bubbleChartData.forEach((record)=> {
      if (record.cve_severity === selectedLegend[Object.keys(selectedLegend)[0]]) {
        record.isVisible = true;
      } else {
        record.isVisible = false;
      }
    });
    this.setState({cve_bubble_chart_data: bubbleChartData});

    // Legend Update
    let activeLegends = JSON.parse(JSON.stringify(this.state.bubbleChartLegends));
    activeLegends.forEach((legend)=> {
      if (selectedLegend[Object.keys(selectedLegend)[0]] === legend.key_name){
        legend.isChecked = true;
      } else {
        legend.isChecked = false;
      }
    });
    this.setState({bubbleChartLegends: activeLegends});

    const filteredData = this.getFilteredData(bubbleChartData);
    this.setState({dataToBePopulate: filteredData});
  }

  getFilteredData(data) {
    const result = [];
    let dataCopy = JSON.parse(JSON.stringify(data));
    dataCopy.forEach((record)=> {
      if (record.isVisible){
        result.push(record);
      }
    });
    return result;
  }

  getBubbleChartView() {
    const { dataToBePopulate } = this.state;
    return (
      <BubbleChart data={dataToBePopulate}
                   onBubbleMouseInCallback={(bubbleData)=> this.handleBubbleMouseInEvent(bubbleData)}
                   onBubbleMouseOutCallback={(bubbleData)=> this.handleBubbleMouseOutEvent(bubbleData)}
                   onBubbleClickCallback={(bubbleData)=> this.handleBubbleClickEvent(bubbleData)}
                   bubbleChartType='vulnerability'
      />
    );
  }

  getBubbleChartEmptyState() {
    const emptyStateWrapper = {
      height: '400px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    }
    return(
      <div style={emptyStateWrapper} className='empty-state-text'>{ EMPTY_STATE_TEXT }</div>
    );
  }

  getBubbleChartLegendsView() {
    const { bubbleChartLegends } = this.state;
    return (
      <D3Legend
        data={bubbleChartLegends}
        donutName="severity"
        onSingleClickCallback={(value) => this.handleSingleClick(value)}
        onDoubleClickCallback={(value) => this.handleDoubleClick(value)} />
    );
  }

  getTooltipView() {
    const { bubbleDetails } = this.state;
    return (
      <div className='bubble-chart-tooltip-wrapper'>
        <div className='tooltip-header'>Vulnerabilities</div>
        <div className='tooltip-body'>
          <div className='tooltip-row'>
            <div className='tooltip-key'>Id</div>
            <div className='tooltip-value'>{bubbleDetails.cve_id}</div>
          </div>
          <div className='tooltip-row'>
            <div className='tooltip-key'>Image</div>
            <div className='tooltip-value'>{bubbleDetails.name}</div>
          </div>
          <div className='tooltip-row'>
            <div className='tooltip-key'>Count</div>
            <div className='tooltip-value'>{bubbleDetails.value}</div>
          </div>
          <div className='tooltip-row'>
            <div className='tooltip-key'>Severity</div>
            <div className='tooltip-value'>{bubbleDetails.cve_severity}</div>
          </div>
          <div className='tooltip-row'>
            <div className='tooltip-key'>Timestamp</div>
            <div className='tooltip-value'>{bubbleDetails.timestamp}</div>
          </div>
        </div>
      </div>
    )
  };

  render() {
    const { cve_bubble_chart_data, isTooltipVisible, bubbleChartLegends } = this.state;
    const alignCenter = {
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    };
    const tooltipSpacer = {
      paddingTop: '20px'
    }
    return (
      <div className={`bubble-chart-view-wrapper ${this.props.isSideNavCollapsed ? 'collapse-side-nav' : 'expand-side-nav'}`}>
        <div className='bubble-chart-wrapper'>
          <div className='col-md-3 col-lg-3' style={alignCenter}>
            <div style={ tooltipSpacer }>{ isTooltipVisible && this.getTooltipView() }</div>
          </div>

          <div className='col-md-6 col-lg-6'>
            { (cve_bubble_chart_data && cve_bubble_chart_data.length > 0) ? this.getBubbleChartView() : this.getBubbleChartEmptyState() }
          </div>

          <div className='col-md-3 col-lg-3' style={alignCenter}>
            <div className='bubble-chart-legends-wrapper'>
              { bubbleChartLegends && this.getBubbleChartLegendsView() }
            </div>
          </div>
        </div>
      </div>
    );
  }
}

function mapStateToProps(state) {
  return {
    isSideNavCollapsed: state.get('isSideNavCollapsed'),
    searchQuery: state.get('globalSearchQuery'),
    days: state.get('alertPanelHistoryBound'),
    refreshInterval: state.get('refreshInterval'),
    cveBubbleChartData: state.get('cveBubbleChartData'),
  };
}

export default connect(
  mapStateToProps
)(CvBubbleChartView);